namespace FpgaSimulator.Tests.Csi2;

using FluentAssertions;
using FpgaSimulator.Core.Csi2;
using McuSimulator.Core.Csi2;
using McuSimulator.Core.Frame;
using Xunit;

/// <summary>
/// Round-trip integration tests verifying that pixels generated by
/// Csi2TxPacketGenerator (FPGA TX) are faithfully recovered by
/// Csi2RxPacketParser and FrameReassembler (MCU RX).
/// </summary>
public class Csi2RoundTripTests
{
    // -----------------------------------------------------------------
    // Helper: build a counter-pattern frame
    // frame[r, c] = (ushort)((r * cols + c) & 0xFFFF)
    // -----------------------------------------------------------------
    private static ushort[,] BuildCounterFrame(int rows, int cols)
    {
        var frame = new ushort[rows, cols];
        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                frame[r, c] = (ushort)((r * cols + c) & 0xFFFF);
            }
        }
        return frame;
    }

    // -----------------------------------------------------------------
    // Test 1: Small frame (16x16) via ParseFullFrame
    // -----------------------------------------------------------------
    [Fact]
    public void CounterPattern_SmallFrame_BitExactRoundTrip()
    {
        // Arrange
        const int rows = 16;
        const int cols = 16;
        var original = BuildCounterFrame(rows, cols);

        var generator = new Csi2TxPacketGenerator();
        var parser = new Csi2RxPacketParser();

        // Act
        var packets = generator.GenerateFullFrame(original);
        var result = parser.ParseFullFrame(packets);

        // Assert
        result.IsValid.Should().BeTrue("ParseFullFrame must report the frame as valid");
        result.Rows.Should().Be(rows);
        result.Cols.Should().Be(cols);

        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                result.Pixels[r, c].Should().Be(
                    original[r, c],
                    because: $"pixel [{r},{c}] must survive the TX->RX round-trip bit-exactly");
            }
        }
    }

    // -----------------------------------------------------------------
    // Test 2: Standard frame (256x256) via FrameReassembler
    // -----------------------------------------------------------------
    [Fact]
    public void CounterPattern_StandardFrame_BitExactRoundTrip()
    {
        // Arrange
        const int rows = 256;
        const int cols = 256;
        var original = BuildCounterFrame(rows, cols);

        var generator = new Csi2TxPacketGenerator();
        var reassembler = new FrameReassembler();

        // Act
        var packets = generator.GenerateFullFrame(original);
        foreach (var packet in packets)
        {
            reassembler.AddPacket(packet);
        }

        var frame = reassembler.GetFrame();

        // Assert
        frame.IsValid.Should().BeTrue("FrameReassembler must produce a valid frame");
        frame.Rows.Should().Be(rows);
        frame.Cols.Should().Be(cols);
        frame.ReceivedLineCount.Should().Be(rows, "all lines must be received");

        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                frame.Pixels[r, c].Should().Be(
                    original[r, c],
                    because: $"pixel [{r},{c}] must survive the TX->FrameReassembler round-trip bit-exactly");
            }
        }
    }

    // -----------------------------------------------------------------
    // Test 3: Packet count equals rows + 2 (FS + lines + FE)
    // -----------------------------------------------------------------
    [Fact]
    public void FullFrame_PacketCount_EqualsRowsPlusTwo()
    {
        // Arrange
        const int rows = 32;
        const int cols = 32;
        var frame = BuildCounterFrame(rows, cols);

        var generator = new Csi2TxPacketGenerator();

        // Act
        var packets = generator.GenerateFullFrame(frame);

        // Assert
        packets.Should().HaveCount(rows + 2,
            because: "GenerateFullFrame must produce exactly FS + <rows> line packets + FE");

        packets[0].PacketType.Should().Be(Csi2PacketType.FrameStart,
            because: "first packet must be Frame Start");

        packets[^1].PacketType.Should().Be(Csi2PacketType.FrameEnd,
            because: "last packet must be Frame End");

        for (int i = 1; i <= rows; i++)
        {
            packets[i].PacketType.Should().Be(Csi2PacketType.LineData,
                because: $"packet[{i}] must be a Line Data packet");
        }
    }

    // -----------------------------------------------------------------
    // Test 4: Large frame (2048x2048) via FrameReassembler
    // -----------------------------------------------------------------
    [Fact]
    public void LargeFrame_2048x2048_BitExactRoundTrip()
    {
        // Arrange
        const int rows = 2048;
        const int cols = 2048;
        var original = BuildCounterFrame(rows, cols);

        var generator = new Csi2TxPacketGenerator();
        var reassembler = new FrameReassembler();

        // Act
        var packets = generator.GenerateFullFrame(original);
        foreach (var packet in packets)
        {
            reassembler.AddPacket(packet);
        }

        var frame = reassembler.GetFrame();

        // Assert
        frame.IsValid.Should().BeTrue("FrameReassembler must produce a valid frame for a 2048x2048 input");
        frame.Rows.Should().Be(rows);
        frame.Cols.Should().Be(cols);
        frame.ReceivedLineCount.Should().Be(rows, "all 2048 lines must be received");

        // Verify every pixel for bit-exact round-trip
        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                if (frame.Pixels[r, c] != original[r, c])
                {
                    // Emit a focused assertion failure rather than looping until timeout
                    frame.Pixels[r, c].Should().Be(
                        original[r, c],
                        because: $"pixel [{r},{c}] must survive the TX->FrameReassembler round-trip bit-exactly");
                }
            }
        }
    }
}
