using Common.Dto.Dtos;
using McuSimulator.Core.Buffer;
using McuSimulator.Core.Command;
using McuSimulator.Core.Frame;
using McuSimulator.Core.Health;
using McuSimulator.Core.Network;
using McuSimulator.Core.Sequence;
using HostSimulator.Core.Configuration;
using HostSimulator.Core.Reassembly;
using PanelSimulator.Models;
using Csi2Packet = FpgaSimulator.Core.Csi2.Csi2Packet;
using Csi2TxPacketGenerator = FpgaSimulator.Core.Csi2.Csi2TxPacketGenerator;
using McuFrameReassembler = McuSimulator.Core.Frame.FrameReassembler;
using McuTopSimulator = McuSimulator.Core.McuTopSimulator;

namespace IntegrationTests.Helpers;

/// <summary>
/// Statistics snapshot for the full pipeline execution.
/// </summary>
public sealed class PipelineStatistics
{
    /// <summary>Total frames processed through the pipeline.</summary>
    public int FramesProcessed { get; init; }

    /// <summary>Total frames successfully reassembled by host.</summary>
    public int FramesCompleted { get; init; }

    /// <summary>Total frames that failed or timed out.</summary>
    public int FramesFailed { get; init; }

    /// <summary>Total UDP packets generated by MCU.</summary>
    public long UdpPacketsGenerated { get; init; }

    /// <summary>Network channel statistics (null if no channel configured).</summary>
    public NetworkChannelStats? NetworkStats { get; init; }
}

/// <summary>
/// Network channel statistics snapshot.
/// </summary>
public sealed class NetworkChannelStats
{
    /// <summary>Packets sent through the channel.</summary>
    public long PacketsSent { get; init; }

    /// <summary>Packets lost due to simulated loss.</summary>
    public long PacketsLost { get; init; }

    /// <summary>Packets reordered by the channel.</summary>
    public long PacketsReordered { get; init; }

    /// <summary>Packets corrupted by the channel.</summary>
    public long PacketsCorrupted { get; init; }
}

/// <summary>
/// Orchestrates the full 4-layer pipeline: Panel -> FPGA -> MCU -> Network -> Host.
/// Provides a high-level API for running frames through the entire simulator stack
/// with optional network impairment and per-layer checkpoint capture.
/// </summary>
public sealed class SimulatorPipeline
{
    private readonly object _lock = new();
    private int _framesProcessed;
    private int _framesCompleted;
    private int _framesFailed;
    private long _udpPacketsGenerated;
    private uint _frameCounter;

    /// <summary>Panel simulator configuration.</summary>
    public PanelConfig PanelConfig { get; }

    /// <summary>Network channel for simulating impairments (null if passthrough).</summary>
    public NetworkChannel? NetworkChannel { get; }

    /// <summary>Host configuration.</summary>
    public HostConfig HostConfig { get; }

    /// <summary>Captured checkpoints from the last frame processing (empty if disabled).</summary>
    public List<PipelineCheckpoint> Checkpoints { get; } = new();

    /// <summary>Whether to capture per-layer checkpoints during processing.</summary>
    public bool EnableCheckpoints { get; set; }

    /// <summary>
    /// Creates a new SimulatorPipeline with the specified configuration.
    /// </summary>
    /// <param name="panelConfig">Panel simulator configuration.</param>
    /// <param name="networkChannel">Optional network channel for impairment simulation.</param>
    /// <param name="hostConfig">Host simulator configuration.</param>
    /// <param name="enableCheckpoints">Whether to capture per-layer checkpoints.</param>
    public SimulatorPipeline(
        PanelConfig panelConfig,
        NetworkChannel? networkChannel = null,
        HostConfig? hostConfig = null,
        bool enableCheckpoints = false)
    {
        PanelConfig = panelConfig ?? throw new ArgumentNullException(nameof(panelConfig));
        NetworkChannel = networkChannel;
        HostConfig = hostConfig ?? new HostConfig { PacketTimeoutMs = 5000 };
        EnableCheckpoints = enableCheckpoints;
    }

    /// <summary>
    /// Processes a single frame through the full 4-layer pipeline.
    /// Panel.Generate -> FPGA.CSI2.TX.Encode -> MCU.Reassemble+UDP.Fragment
    /// -> NetworkChannel -> Host.Reassemble -> FrameData
    /// </summary>
    /// <returns>Final reassembled FrameData from the Host layer, or null on failure.</returns>
    public FrameData? ProcessFrame()
    {
        lock (_lock)
        {
            Checkpoints.Clear();
            _framesProcessed++;

            // Layer 1: Panel - Generate pixel data
            var panel = new PanelSimulator.PanelSimulator();
            panel.Initialize(PanelConfig);

            FrameData panelOutput;
            if (EnableCheckpoints)
            {
                var cp = PipelineCheckpoint.Capture("Panel", PanelConfig, () =>
                {
                    return (FrameData)panel.Process(new object());
                });
                panelOutput = (FrameData)cp.OutputData;
                Checkpoints.Add(cp);
            }
            else
            {
                panelOutput = (FrameData)panel.Process(new object());
            }

            // Convert 1D to 2D for FPGA input
            var pixels2D = SimulatorPipelineBuilder.ConvertTo2D(
                panelOutput.Pixels, panelOutput.Height, panelOutput.Width);

            // Layer 2: FPGA - Convert to CSI-2 packets
            Csi2Packet[] csi2Packets;
            if (EnableCheckpoints)
            {
                var cp = PipelineCheckpoint.Capture("FPGA", pixels2D, () =>
                {
                    var tx = new Csi2TxPacketGenerator();
                    return tx.GenerateFullFrame(pixels2D);
                });
                csi2Packets = (Csi2Packet[])cp.OutputData;
                Checkpoints.Add(cp);
            }
            else
            {
                var tx = new Csi2TxPacketGenerator();
                csi2Packets = tx.GenerateFullFrame(pixels2D);
            }

            // Layer 3: MCU - Reassemble CSI-2 packets, then fragment to UDP
            List<UdpFramePacket> udpPackets;
            if (EnableCheckpoints)
            {
                var cp = PipelineCheckpoint.Capture("MCU", csi2Packets, () =>
                {
                    var reassembler = new McuFrameReassembler();
                    foreach (var pkt in csi2Packets)
                    {
                        reassembler.AddPacket(pkt);
                    }
                    var frame = reassembler.GetFrame();

                    var transmitter = new UdpFrameTransmitter();
                    return transmitter.FragmentFrame(frame.Pixels, _frameCounter);
                });
                udpPackets = (List<UdpFramePacket>)cp.OutputData;
                Checkpoints.Add(cp);
            }
            else
            {
                var reassembler = new McuFrameReassembler();
                foreach (var pkt in csi2Packets)
                {
                    reassembler.AddPacket(pkt);
                }
                var frame = reassembler.GetFrame();

                var transmitter = new UdpFrameTransmitter();
                udpPackets = transmitter.FragmentFrame(frame.Pixels, _frameCounter);
            }

            _udpPacketsGenerated += udpPackets.Count;

            // Network Channel - Apply loss/reorder/corruption
            List<UdpFramePacket> networkOutput;
            if (NetworkChannel != null)
            {
                if (EnableCheckpoints)
                {
                    var cp = PipelineCheckpoint.Capture("Network", udpPackets, () =>
                    {
                        return NetworkChannel.TransmitPackets(udpPackets);
                    });
                    networkOutput = (List<UdpFramePacket>)cp.OutputData;
                    Checkpoints.Add(cp);
                }
                else
                {
                    networkOutput = NetworkChannel.TransmitPackets(udpPackets);
                }
            }
            else
            {
                networkOutput = udpPackets;
            }

            // Layer 4: Host - Receive UDP packets and reassemble
            FrameData? hostOutput;
            if (EnableCheckpoints)
            {
                var cp = PipelineCheckpoint.Capture("Host", networkOutput, () =>
                {
                    return ReassembleAtHost(networkOutput);
                });
                hostOutput = cp.OutputData as FrameData;
                Checkpoints.Add(cp);
            }
            else
            {
                hostOutput = ReassembleAtHost(networkOutput);
            }

            _frameCounter++;

            if (hostOutput != null)
            {
                _framesCompleted++;
            }
            else
            {
                _framesFailed++;
            }

            return hostOutput;
        }
    }

    /// <summary>
    /// Sets the packet loss rate on the network channel.
    /// </summary>
    /// <param name="rate">Loss rate (0.0-1.0).</param>
    public void SetPacketLossRate(double rate)
    {
        if (NetworkChannel == null)
            throw new InvalidOperationException("No network channel configured.");
        NetworkChannel.SetLossRate(rate);
    }

    /// <summary>
    /// Sets the packet reorder rate on the network channel.
    /// </summary>
    /// <param name="rate">Reorder rate (0.0-1.0).</param>
    public void SetPacketReorderRate(double rate)
    {
        if (NetworkChannel == null)
            throw new InvalidOperationException("No network channel configured.");
        NetworkChannel.SetReorderRate(rate);
    }

    /// <summary>
    /// Gets a snapshot of pipeline statistics.
    /// </summary>
    /// <returns>Current pipeline statistics.</returns>
    public PipelineStatistics GetStatistics()
    {
        lock (_lock)
        {
            NetworkChannelStats? networkStats = null;
            if (NetworkChannel != null)
            {
                networkStats = new NetworkChannelStats
                {
                    PacketsSent = NetworkChannel.PacketsSent,
                    PacketsLost = NetworkChannel.PacketsLost,
                    PacketsReordered = NetworkChannel.PacketsReordered,
                    PacketsCorrupted = NetworkChannel.PacketsCorrupted
                };
            }

            return new PipelineStatistics
            {
                FramesProcessed = _framesProcessed,
                FramesCompleted = _framesCompleted,
                FramesFailed = _framesFailed,
                UdpPacketsGenerated = _udpPacketsGenerated,
                NetworkStats = networkStats
            };
        }
    }

    /// <summary>
    /// Reassembles UDP packets into a FrameData at the Host layer.
    /// </summary>
    private FrameData? ReassembleAtHost(List<UdpFramePacket> packets)
    {
        var hostSim = new HostSimulator.Core.HostSimulator();
        hostSim.Initialize(HostConfig);

        FrameData? result = null;
        foreach (var udpPacket in packets)
        {
            var output = hostSim.Process(udpPacket.Data);
            if (output is FrameData fd)
            {
                result = fd;
            }
        }

        return result;
    }
}
